<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã€2048ã€‘</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Clear Sans', 'Helvetica Neue', Arial, sans-serif;
            background-color: #faf8ef;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            flex-direction: column;
            overflow: hidden; /* é˜²æ­¢åŠ¨ç”»æº¢å‡ºå¯¼è‡´æ»šåŠ¨æ¡ */
            -webkit-user-select: none; /* ç¦ç”¨æ–‡æœ¬é€‰æ‹© */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent; /* ç¦ç”¨ç‚¹å‡»é«˜äº® */
        }

        .game-container {
            background-color: #bbada0;
            border-radius: 6px;
            padding: var(--grid-gap); /* ä½¿ç”¨ CSS å˜é‡ä¿æŒä¸€è‡´ */
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            grid-template-rows: repeat(var(--grid-size), 1fr);
            gap: var(--grid-gap);
            width: var(--container-width);
            height: var(--container-height);
            position: relative; /* ç”¨äºå­çº§ç –å—çš„ç»å¯¹å®šä½ */
            touch-action: none; /* ç¦ç”¨æµè§ˆå™¨é»˜è®¤çš„è§¦æ§è¡Œä¸ºï¼ˆå¦‚æ»šåŠ¨ï¼‰ */
        }

        .grid-cell {
            width: 100%;
            height: 100%;
            background-color: rgba(238, 228, 218, 0.35);
            border-radius: 3px;
        }

        .tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 3px;
            font-weight: bold;
            z-index: 2; /* ç –å—åº”åœ¨ç½‘æ ¼å•å…ƒæ ¼ä¹‹ä¸Š */

            /* ç –å—å°ºå¯¸å’Œä½ç½®çš„ CSS å˜é‡ */
            --tile-size: calc((var(--container-width) - (var(--grid-size) + 1) * var(--grid-gap)) / var(--grid-size));
            width: var(--tile-size);
            height: var(--tile-size);
            font-size: calc(var(--tile-size) / 3); /* åŠ¨æ€å­—ä½“å¤§å° */

            /* ç§»åŠ¨åŠ¨ç”»çš„é»˜è®¤è¿‡æ¸¡æ•ˆæœ */
            transition: transform 0.15s ease-out, background-color 0.15s ease-in-out, color 0.15s ease-in-out;
            /* transform å€¼ç”± JS è®¾ç½® */
        }

        /* ç –å—å‡ºç°åŠ¨ç”»ï¼ˆç”¨äºæ–°ç –å—ï¼‰ */
        .tile.tile-new {
            transform: scale(0);
            opacity: 0;
            animation: appear 0.2s ease-out forwards;
        }

        @keyframes appear {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* ç –å—åˆå¹¶åŠ¨ç”»ï¼ˆè„‰å†²æ•ˆæœï¼‰ */
        .tile.tile-merged-anim {
            animation: merged-pulse 0.2s ease-in-out;
        }

        @keyframes merged-pulse {
            0% { transform: translate(var(--tile-x), var(--tile-y)) scale(1); }
            50% { transform: translate(var(--tile-x), var(--tile-y)) scale(1.15); } /* ç¨å¾®å¼ºä¸€ç‚¹çš„è„‰å†² */
            100% { transform: translate(var(--tile-x), var(--tile-y)) scale(1); }
        }

        /* ç –å—é¢œè‰² */
        .tile-2 { background-color: #eee4da; color: #776e65; }
        .tile-4 { background-color: #ede0c8; color: #776e65; }
        .tile-8 { background-color: #f2b179; color: #f9f6f2; }
        .tile-16 { background-color: #f59563; color: #f9f6f2; }
        .tile-32 { background-color: #f67c5f; color: #f9f6f2; }
        .tile-64 { background-color: #f65e3b; color: #f9f6f2; }
        .tile-128 { background-color: #edcf72; color: #f9f6f2; font-size: calc(var(--tile-size) / 3.5); }
        .tile-256 { background-color: #edcc61; color: #f9f6f2; font-size: calc(var(--tile-size) / 3.5); }
        .tile-512 { background-color: #edc850; color: #f9f6f2; font-size: calc(var(--tile-size) / 3.5); }
        .tile-1024 { background-color: #edc53f; color: #f9f9f2; font-size: calc(var(--tile-size) / 4); } /* Adjust text color slightly */
        .tile-2048 { background-color: #edc22e; color: #f9f9f2; font-size: calc(var(--tile-size) / 4); } /* Adjust text color slightly */
        /* éœ€è¦æ›´å¤šç –å—å€¼æ—¶ï¼ˆå¦‚ 4096, 8192ï¼‰ï¼Œè¯·åœ¨æ­¤å¤„æ·»åŠ æ ·å¼ */
        .tile-4096 { background-color: #60d9ee; color: #f9f6f2; font-size: calc(var(--tile-size) / 4); }
        .tile-8192 { background-color: #3b88ea; color: #f9f6f2; font-size: calc(var(--tile-size) / 4); }


        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            color: #776e65;
            z-index: 10;
            border-radius: 6px;
        }

        .new-game-button {
            padding: 10px 20px;
            background-color: #8f7a66;
            color: #f9f6f2;
            border-radius: 3px;
            cursor: pointer;
            font-size: 1.2rem;
            margin-top: 20px;
            border: none;
            outline: none;
            transition: background-color 0.2s;
        }

        .new-game-button:hover {
            background-color: #9f8a76;
        }
    </style>
</head>
<body>
    <div class="flex flex-col items-center mb-6">
        <h1 class="text-6xl font-bold text-gray-700 mb-4">2048</h1>
        <div class="flex gap-4">
            <div class="bg-gray-800 text-white p-3 rounded-md text-xl font-bold">
                åˆ†æ•°: <span id="score">0</span>
            </div>
            <button id="new-game-btn-top" class="new-game-button !mt-0 !bg-orange-500 hover:!bg-orange-600">æ–°æ¸¸æˆ</button>
        </div>
    </div>

    <div id="game-board" class="game-container relative">
        <!-- ç½‘æ ¼å•å…ƒæ ¼å°†ç”± JS ç”Ÿæˆ -->
        <!-- ç –å—å°†ä½œä¸ºå­å…ƒç´ åŠ¨æ€æ·»åŠ ï¼Œç”¨äºç»å¯¹å®šä½ -->
    </div>

    <script>
        const GRID_SIZE = 4;
        const GRID_GAP = 12; // px
        const CONTAINER_WIDTH = 500; // px
        const ANIMATION_DURATION = 150; // ms (åº”ä¸ CSS transition æŒç»­æ—¶é—´åŒ¹é…)
        const TOUCH_SWIPE_THRESHOLD = 50; // è§¦æ‘¸æ»‘åŠ¨æœ€å°è·ç¦» (px)

        // è®¾ç½® CSS å˜é‡ï¼Œä¾›æ ·å¼ä½¿ç”¨
        document.documentElement.style.setProperty('--grid-size', GRID_SIZE);
        document.documentElement.style.setProperty('--grid-gap', `${GRID_GAP}px`);
        document.documentElement.style.setProperty('--container-width', `${CONTAINER_WIDTH}px`);
        document.documentElement.style.setProperty('--container-height', `${CONTAINER_WIDTH}px`); /* ä½¿å…¶ä¸ºæ­£æ–¹å½¢ */

        const TILE_SIZE = (CONTAINER_WIDTH - (GRID_SIZE + 1) * GRID_GAP) / GRID_SIZE;

        let board = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(null)); // å­˜å‚¨ Tile å¯¹è±¡æˆ– null
        let tiles = new Map(); // Map<tileId, TileObject> ç”¨äºå¿«é€ŸæŸ¥æ‰¾å’Œç®¡ç†æ‰€æœ‰æ´»åŠ¨ç –å—
        let nextTileId = 0; // æ¯ä¸ªç –å—çš„å”¯ä¸€ ID
        let score = 0;
        let gameOver = false;
        let win = false;
        let isAnimating = false; // ç”¨äºé˜²æ­¢åŠ¨ç”»æœŸé—´å“åº”æ–°çš„ç§»åŠ¨æ“ä½œ

        const gameBoardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const newGameButtonTop = document.getElementById('new-game-btn-top');

        // --- è§¦æ§å˜é‡ ---
        let touchStartX = 0;
        let touchStartY = 0;
        // --- è§¦æ§å˜é‡ç»“æŸ ---

        // --- éŸ³æ•ˆåˆæˆéƒ¨åˆ† ---
        // ä½¿ç”¨å•ä¾‹æ¨¡å¼è·å– AudioContext
        let audioContext = null;
        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        // é€šç”¨æ’­æ”¾å‡½æ•°
        function playSound(soundType) {
            // Web Audio API é€šå¸¸è¦æ±‚æœ‰ç”¨æˆ·äº¤äº’æ‰èƒ½é¦–æ¬¡æ’­æ”¾å£°éŸ³ã€‚
            // ç¡®ä¿åœ¨ç¬¬ä¸€æ¬¡ç”¨æˆ·äº¤äº’ï¼ˆä¾‹å¦‚ç‚¹å‡»æ–°æ¸¸æˆæŒ‰é’®ï¼‰ååˆå§‹åŒ–æˆ–æ¢å¤ AudioContextã€‚
            // æˆ‘ä»¬çš„æ¸¸æˆé€»è¾‘å·²ç»ç¡®ä¿äº†è¿™ä¸€ç‚¹ï¼Œå› ä¸º playSound æ˜¯åœ¨ç”¨æˆ·æ“ä½œåæ‰è°ƒç”¨çš„ã€‚
            const context = getAudioContext();
            if (context.state === 'suspended') {
                context.resume().then(() => {
                    // console.log('AudioContext resumed!');
                    _playSoundImpl(soundType);
                }).catch(e => console.error('Error resuming AudioContext:', e));
            } else {
                _playSoundImpl(soundType);
            }
        }

        function _playSoundImpl(soundType) {
            switch (soundType) {
                case 'move':
                    playMoveEffect();
                    break;
                case 'merge':
                    playMergeEffect();
                    break;
                case 'newTile':
                    playNewTileEffect();
                    break;
                case 'gameOver':
                    playGameOverEffect();
                    break;
                case 'win':
                    playWinEffect();
                    break;
            }
        }

        // 1. æ–°ç –å—å‡ºç°éŸ³æ•ˆ (æ¸…è„†çš„é«˜é¢‘â€œå®â€å£°)
        function playNewTileEffect() {
            const context = getAudioContext();
            const oscillator = context.createOscillator();
            const gainNode = context.createGain();

            oscillator.type = 'sine'; // æ­£å¼¦æ³¢ï¼Œæœ€çº¯å‡€
            oscillator.frequency.value = 980; // æ›´é«˜çš„é¢‘ç‡ï¼Œå¬èµ·æ¥æ›´è½»å¿«

            gainNode.gain.setValueAtTime(0, context.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.4, context.currentTime + 0.005); // æé€Ÿæ¸å¼º (Attack)
            gainNode.gain.exponentialRampToValueAtTime(0.001, context.currentTime + 0.12); // æ›´å¿«çš„æŒ‡æ•°æ¸å¼± (Release)

            oscillator.connect(gainNode);
            gainNode.connect(context.destination);

            oscillator.start(context.currentTime);
            oscillator.stop(context.currentTime + 0.12); // çŸ­æš‚çš„æŒç»­æ—¶é—´
        }

        // 2. åˆå¹¶éŸ³æ•ˆ (æœ‰åŠ›ä¸”æ¸…è„†çš„â€œç °â€å£°)
        function playMergeEffect() {
            const context = getAudioContext();
            const oscillator = context.createOscillator();
            const gainNode = context.createGain();
            const filter = context.createBiquadFilter();

            oscillator.type = 'triangle'; // ä¸‰è§’æ³¢ï¼Œæ¯”é”¯é½¿æ³¢æŸ”å’Œï¼Œæ¯”æ­£å¼¦æ³¢æœ‰æ›´å¤šæ³›éŸ³
            oscillator.frequency.value = 400; // è¾ƒä¸­ç­‰çš„é¢‘ç‡

            // ç¨å¾®è°ƒé«˜ä¸€ç‚¹é¢‘ç‡ï¼Œè¥é€ â€œä¸Šå‡â€æ„Ÿ
            oscillator.frequency.setValueAtTime(400, context.currentTime);
            oscillator.frequency.linearRampToValueAtTime(800, context.currentTime + 0.05);

            filter.type = 'lowpass'; // ä½é€šæ»¤æ³¢å™¨
            filter.frequency.setValueAtTime(2000, context.currentTime); // åˆå§‹æˆªæ­¢é¢‘ç‡
            filter.Q.setValueAtTime(1, context.currentTime); // åˆå§‹Qå€¼

            gainNode.gain.setValueAtTime(0, context.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.6, context.currentTime + 0.01); // å¿«é€Ÿæ”»å‡»ï¼Œæ›´å¼ºçš„å³°å€¼
            gainNode.gain.exponentialRampToValueAtTime(0.001, context.currentTime + 0.2); // å¿«é€Ÿè¡°å‡

            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(context.destination);

            oscillator.start(context.currentTime);
            oscillator.stop(context.currentTime + 0.2);
        }

        // 3. ç§»åŠ¨éŸ³æ•ˆ (æ›´æµç•…ã€æ¸…æ¾ˆçš„â€œå—–â€å£°)
        function playMoveEffect() {
            const context = getAudioContext();
            const bufferSize = context.sampleRate * 0.1; // 0.1 ç§’çš„ç™½å™ªéŸ³
            const buffer = context.createBuffer(1, bufferSize, context.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1; // ç”Ÿæˆç™½å™ªéŸ³
            }

            const noise = context.createBufferSource();
            noise.buffer = buffer;

            const filter = context.createBiquadFilter();
            filter.type = 'bandpass'; // å¸¦é€šæ»¤æ³¢å™¨
            filter.frequency.setValueAtTime(300, context.currentTime); // åˆå§‹é¢‘ç‡æ›´ä½
            filter.frequency.linearRampToValueAtTime(4500, context.currentTime + 0.1); // æ‰«é¢‘èŒƒå›´æ›´å¹¿ï¼Œæ„Ÿè§‰æ›´â€œå—–â€

            const gainNode = context.createGain();
            gainNode.gain.setValueAtTime(0, context.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.25, context.currentTime + 0.01); // ç•¥å¾®å¢åŠ å³°å€¼
            gainNode.gain.linearRampToValueAtTime(0, context.currentTime + 0.1); // å¿«é€Ÿè¡°å‡

            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(context.destination);

            noise.start(context.currentTime);
            noise.stop(context.currentTime + 0.1);
        }

        // 4. æ¸¸æˆç»“æŸéŸ³æ•ˆ (æŸ”å’Œè€Œæ‚²ä¼¤çš„ä¸‹é™éŸ³)
        function playGameOverEffect() {
            const context = getAudioContext();
            const oscillator1 = context.createOscillator();
            const oscillator2 = context.createOscillator();
            const gainNode = context.createGain();

            oscillator1.type = 'triangle'; // æŸ”å’Œçš„ä¸‰è§’æ³¢
            oscillator2.type = 'triangle';

            // é¢‘ç‡ä»é«˜åˆ°ä½ä¸‹é™ï¼Œä½†æ›´å¹³æ»‘ï¼Œä¸”ç•¥æœ‰å¤±è°æ„Ÿ
            oscillator1.frequency.setValueAtTime(280, context.currentTime);
            oscillator1.frequency.linearRampToValueAtTime(140, context.currentTime + 0.8);

            oscillator2.frequency.setValueAtTime(270, context.currentTime); // æ¯” oscillator1 ç•¥ä½ï¼Œåˆ¶é€ ä¸€ç‚¹ä¸å’Œè°ä½†å¹¶éåˆºè€³æ„Ÿ
            oscillator2.frequency.linearRampToValueAtTime(130, context.currentTime + 0.8);

            gainNode.gain.setValueAtTime(0.3, context.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.001, context.currentTime + 0.7); // æ¸å‡ºæ—¶é—´ç¨çŸ­

            oscillator1.connect(gainNode);
            oscillator2.connect(gainNode);
            gainNode.connect(context.destination);

            oscillator1.start(context.currentTime);
            oscillator2.start(context.currentTime);
            oscillator1.stop(context.currentTime + 0.8);
            oscillator2.stop(context.currentTime + 0.8);
        }

        // 5. èƒœåˆ©éŸ³æ•ˆ (æ¬¢å¿«ä¸”æ›´æ¸…æ™°çš„ä¸Šå‡ç¶éŸ³)
        function playWinEffect() {
            const context = getAudioContext();
            const baseFreq = 660; // E5
            const notes = [0, 2, 4, 7, 12]; // E, F#, G#, B, E (é«˜å…«åº¦)
            const durationPerNote = 0.12; // æ¯ä¸ªéŸ³ç¬¦çš„æŒç»­æ—¶é—´ç•¥é•¿ä¸€ç‚¹ç‚¹
            const totalDuration = notes.length * durationPerNote;

            notes.forEach((semitoneOffset, index) => {
                const freq = baseFreq * Math.pow(2, semitoneOffset / 12);
                const startTime = context.currentTime + index * durationPerNote;

                const oscillator = context.createOscillator();
                const gainNode = context.createGain();

                oscillator.type = 'sine'; // ä½¿ç”¨æ­£å¼¦æ³¢ï¼Œæ›´çº¯å‡€ï¼Œæ¯ä¸ªéŸ³ç¬¦æ›´çªå‡º
                oscillator.frequency.setValueAtTime(freq, startTime);

                // æ›´æ¸…æ™°çš„ ADSR åŒ…ç»œ
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.25, startTime + 0.01); // å¿«é€Ÿæ”»å‡»ï¼Œç•¥é«˜éŸ³é‡
                gainNode.gain.linearRampToValueAtTime(0.15, startTime + 0.03); // å¿«é€Ÿè¡°å‡åˆ° sustain
                gainNode.gain.linearRampToValueAtTime(0.001, startTime + durationPerNote - 0.02); // é‡Šæ”¾æ—¶é—´

                oscillator.connect(gainNode);
                gainNode.connect(context.destination);

                oscillator.start(startTime);
                oscillator.stop(startTime + durationPerNote);
            });
        }
        // --- éŸ³æ•ˆåˆæˆéƒ¨åˆ†ç»“æŸ ---


        class Tile {
            constructor(value, r, c, id) {
                this.id = id || nextTileId++;
                this.value = value;
                this.r = r;
                this.c = c;
                this.oldR = r; // ç”¨äºè·Ÿè¸ªåŠ¨ç”»èµ·å§‹ä½ç½®çš„æ—§è¡Œå·
                this.oldC = c; // ç”¨äºè·Ÿè¸ªåŠ¨ç”»èµ·å§‹ä½ç½®çš„æ—§åˆ—å·
                this.mergedFrom = null; // å­˜å‚¨åˆå¹¶åˆ°æ­¤ç –å—çš„ç –å— ID æ•°ç»„
                this.isNew = true; // ç”¨äºåˆå§‹å‡ºç°åŠ¨ç”»çš„æ ‡å¿—
                this.element = null; // DOM å…ƒç´ å¼•ç”¨
            }

            // è®¡ç®—ç –å—åœ¨æ£‹ç›˜ä¸Šçš„åƒç´ ä½ç½®
            get x() { return this.c * (TILE_SIZE + GRID_GAP) + GRID_GAP; }
            get y() { return this.r * (TILE_SIZE + GRID_GAP) + GRID_GAP; }
        }

        function initializeGame() {
            board = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(null));
            tiles.clear();
            nextTileId = 0;
            score = 0;
            gameOver = false;
            win = false;
            isAnimating = false;
            scoreElement.textContent = score;

            // æ¸…é™¤ä»»ä½•ç°æœ‰çš„æ¸¸æˆç»“æŸ/èƒœåˆ©è¦†ç›–å±‚
            const existingOverlay = document.querySelector('.game-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }

            // æ¸…é™¤ DOM ä¸­ç°æœ‰çš„ç –å—å…ƒç´ 
            gameBoardElement.querySelectorAll('.tile').forEach(tileEl => tileEl.remove());
            // é‡æ–°æ¸²æŸ“ç½‘æ ¼å•å…ƒæ ¼ï¼ˆå¦‚æœå°šæœªå­˜åœ¨ï¼‰
            renderGridCells();

            addRandomTile();
            addRandomTile();
            renderTiles(); // åˆå§‹æ¸²æŸ“ç –å—
        }

        function renderGridCells() {
            // åªæ¸²æŸ“ä¸€æ¬¡ç½‘æ ¼å•å…ƒæ ¼ï¼Œå®ƒä»¬æ˜¯é™æ€èƒŒæ™¯
            if (gameBoardElement.querySelectorAll('.grid-cell').length === 0) {
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const gridCell = document.createElement('div');
                        gridCell.classList.add('grid-cell');
                        gameBoardElement.appendChild(gridCell);
                    }
                }
            }
        }

        function renderTiles() {
            tiles.forEach(tile => {
                if (!tile.element) {
                    // ä¸ºç –å—åˆ›å»ºæ–°çš„ DOM å…ƒç´ 
                    tile.element = document.createElement('div');
                    tile.element.id = `tile-${tile.id}`;
                    tile.element.classList.add('tile');
                    tile.element.textContent = tile.value;
                    gameBoardElement.appendChild(tile.element);

                    // å¯¹äºæ–°ç –å—ï¼Œæ·»åŠ  'tile-new' ç±»ä»¥å®ç°å‡ºç°åŠ¨ç”»
                    if (tile.isNew) {
                        tile.element.classList.add('tile-new');
                        // åŠ¨ç”»ç»“æŸåç§»é™¤è¯¥ç±»ï¼Œä»¥å…è®¸åç»­ç§»åŠ¨
                        tile.element.addEventListener('animationend', () => {
                            tile.element.classList.remove('tile-new');
                        }, { once: true });
                        tile.isNew = false; // åˆå§‹æ¸²æŸ“åæ ‡è®°ä¸ºéæ–°ç –å—
                    }
                }

                // æ›´æ–°ç –å—å€¼å’Œç±»
                tile.element.textContent = tile.value;
                // ç§»é™¤æ‰€æœ‰ tile-X ç±»å¹¶æ·»åŠ æ­£ç¡®çš„ç±»
                tile.element.className = 'tile'; // é‡ç½®ç±»
                tile.element.classList.add(`tile-${tile.value}`);

                // ä½¿ç”¨ transform è®¾ç½®ä½ç½®
                tile.element.style.transform = `translate(${tile.x}px, ${tile.y}px)`;
                // ä¸ºåˆå¹¶åŠ¨ç”»è®¾ç½® CSS å˜é‡
                tile.element.style.setProperty('--tile-x', `${tile.x}px`);
                tile.element.style.setProperty('--tile-y', `${tile.y}px`);

                // å¤„ç†åˆå¹¶ç –å—çš„æ¸…ç†å’Œè„‰å†²åŠ¨ç”»
                if (tile.mergedFrom) {
                    // ä» DOM ä¸­ç§»é™¤æºç –å—ï¼ˆå®ƒä»¬æ»‘å…¥å¹¶è¢«åˆå¹¶äº†ï¼‰
                    tile.mergedFrom.forEach(mergedId => {
                        const mergedTileEl = document.getElementById(`tile-${mergedId}`);
                        if (mergedTileEl) {
                            mergedTileEl.remove();
                            // å¦‚æœè¿˜å­˜åœ¨äº tiles map ä¸­ï¼Œä¹Ÿå¯¹å…¶è¿›è¡Œåˆ é™¤å¤„ç†
                            tiles.delete(mergedId);
                        }
                    });
                    tile.mergedFrom = null; // å¤„ç†åæ¸…é™¤ mergedFrom æ ‡å¿—

                    // å¯¹ç›®æ ‡ç –å—æ·»åŠ è„‰å†²åŠ¨ç”»
                    tile.element.classList.add('tile-merged-anim');
                    // åŠ¨ç”»ç»“æŸåç§»é™¤è¯¥ç±»
                    tile.element.addEventListener('animationend', () => {
                        tile.element.classList.remove('tile-merged-anim');
                    }, { once: true });
                }
            });
        }

        function addRandomTile() {
            if (isBoardFull()) {
                return;
            }

            let emptyCells = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[r][c] === null) {
                        emptyCells.push({ r, c });
                    }
                }
            }

            if (emptyCells.length > 0) {
                const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const newValue = Math.random() < 0.9 ? 2 : 4; // 90% æ¦‚ç‡ç”Ÿæˆ 2ï¼Œ10% æ¦‚ç‡ç”Ÿæˆ 4
                const newTile = new Tile(newValue, r, c);
                board[r][c] = newTile;
                tiles.set(newTile.id, newTile);
                playSound('newTile'); // æ·»åŠ æ–°ç –å—æ—¶æ’­æ”¾éŸ³æ•ˆ
            }
        }

        function isBoardFull() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[r][c] === null) {
                        return false;
                    }
                }
            }
            return true;
        }

        function checkGameOver() {
            if (!isBoardFull()) {
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰å¯è¡Œçš„åˆå¹¶ï¼ˆæ°´å¹³æˆ–å‚ç›´ï¼‰
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const tile = board[r][c];
                    if (!tile) continue; // æ£‹ç›˜å·²æ»¡æ—¶ä¸åº”è¯¥å‘ç”Ÿï¼Œä½†ä½œä¸ºå®‰å…¨æªæ–½

                    const value = tile.value;
                    // æ£€æŸ¥å³ä¾§
                    if (c + 1 < GRID_SIZE && board[r][c + 1] && board[r][c + 1].value === value) {
                        return false; // å­˜åœ¨å¯åˆå¹¶é¡¹
                    }
                    // æ£€æŸ¥ä¸‹æ–¹
                    if (r + 1 < GRID_SIZE && board[r + 1][c] && board[r + 1][c].value === value) {
                        return false; // å­˜åœ¨å¯åˆå¹¶é¡¹
                    }
                }
            }
            return true; // æ²¡æœ‰ç©ºå•å…ƒæ ¼ä¸”æ²¡æœ‰å¯åˆå¹¶é¡¹
        }

        function showOverlay(message, isWin) {
            const overlay = document.createElement('div');
            overlay.classList.add('game-overlay');
            overlay.innerHTML = `
                <p>${message}</p>
                <button id="restart-game-btn" class="new-game-button">${isWin ? 'ç»§ç»­æ¸¸æˆ' : 'å†æ¥ä¸€å±€'}</button>
            `;
            gameBoardElement.appendChild(overlay);

            if (isWin) {
                playSound('win');
            } else {
                playSound('gameOver');
            }

            document.getElementById('restart-game-btn').addEventListener('click', () => {
                if (isWin) { // å¦‚æœèƒœåˆ©ï¼Œå…è®¸ç»§ç»­æ¸¸æˆ (è¿™æ˜¯ 2048 çš„ä¸€ä¸ªå¸¸è§å˜ä½“)
                    overlay.remove();
                    win = false; // é‡ç½®èƒœåˆ©æ ‡å¿—ï¼Œä»¥ä¾¿å¯ä»¥ç»§ç»­ç§»åŠ¨
                    isAnimating = false; // è§£é”æ¸¸æˆ
                } else {
                    initializeGame();
                }
            });
        }


        // --- æ¸¸æˆé€»è¾‘æ ¸å¿ƒï¼šç§»åŠ¨å‡½æ•° ---
        // è¾…åŠ©å‡½æ•°ï¼šæ»‘åŠ¨å¹¶åˆæ‹¢å•è¡Œï¼ˆæˆ–å•åˆ—ï¼‰
        function operateLine(currentLine) {
            let processedLine = currentLine.filter(tile => tile !== null); // ç§»é™¤ç©ºå•å…ƒæ ¼
            let newScoreAdded = 0;
            let hasMergedInLine = false; // è·Ÿè¸ªæ­¤è¡Œæ˜¯å¦å‘ç”Ÿäº†åˆå¹¶

            // 1. åˆå¹¶æ“ä½œ
            for (let i = 0; i < processedLine.length - 1; i++) {
                if (processedLine[i].value !== 0 && processedLine[i].value === processedLine[i + 1].value) {
                    const mergedValue = processedLine[i].value * 2;
                    newScoreAdded += mergedValue;
                    hasMergedInLine = true;

                    // æ›´æ–°ç¬¬ä¸€ä¸ªç –å—çš„å€¼
                    processedLine[i].value = mergedValue;
                    // æ ‡è®°ç¬¬ä¸€ä¸ªç –å—å¸æ”¶äº†ç¬¬äºŒä¸ªç –å—
                    processedLine[i].mergedFrom = processedLine[i].mergedFrom || [];
                    processedLine[i].mergedFrom.push(processedLine[i+1].id);

                    // ä»å¤„ç†åçš„è¡Œä¸­æ¦‚å¿µæ€§åœ°ç§»é™¤ç¬¬äºŒä¸ªç –å—ï¼ˆå®ƒç¨åä¼šä» DOM ä¸­ç§»é™¤ï¼‰
                    processedLine.splice(i + 1, 1);
                    i--; // é€’å‡ i ä»¥é‡æ–°æ£€æŸ¥æ­¤ä½ç½®å¤„çš„æ–°ç –å—ï¼ˆæˆ–è¡Œçš„å‰©ä½™éƒ¨åˆ†ï¼‰
                    if (mergedValue === 2048) {
                        win = true; // è¾¾åˆ° 2048 èƒœåˆ©æ¡ä»¶
                    }
                }
            }

            // 2. å°†è¡Œå¡«å……å› GRID_SIZEï¼Œç”¨ null å¡«å……ç©ºä½
            let newLine = Array(GRID_SIZE).fill(null);
            for (let i = 0; i < processedLine.length; i++) {
                newLine[i] = processedLine[i];
            }

            // æ£€æŸ¥è¡Œæ˜¯å¦å®é™…å‘ç”Ÿäº†å˜åŒ–ï¼ˆç –å—ä½ç½®ã€å€¼å˜åŒ–æˆ–æ•°é‡å˜åŒ–ï¼‰
            let hasMovedInLine = false;
            for(let i = 0; i < GRID_SIZE; i++) {
                const oldTileInLine = currentLine[i];
                const newTileInLine = newLine[i];

                // å¦‚æœæ—§ä½ç½®æœ‰ç –å—ä½†æ–°ä½ç½®æ²¡æœ‰ (è¡¨ç¤ºç –å—è¢«ç§»èµ°æˆ–åˆå¹¶äº†)
                // æˆ–è€…æ–°ä½ç½®æœ‰ç –å—ä½†æ—§ä½ç½®æ²¡æœ‰ (è¡¨ç¤ºæœ‰æ–°ç –å—æ»‘å…¥è¯¥ä½ç½®)
                // æˆ–è€…åŒä¸€ä¸ªç –å—ï¼Œä½†å…¶åœ¨è¿™ä¸€è¡Œçš„é€»è¾‘ä½ç½®æ”¹å˜äº†
                if ((oldTileInLine !== null && newTileInLine === null) ||
                    (oldTileInLine === null && newTileInLine !== null) ||
                    (oldTileInLine && newTileInLine && oldTileInLine.id !== newTileInLine.id) || // ä¸åŒç –å—
                    (oldTileInLine && newTileInLine && oldTileInLine.id === newTileInLine.id &&
                     // æ£€æŸ¥å…¶åœ¨åŸå§‹çº¿å’Œæ–°çº¿ä¸­çš„ç´¢å¼•æ˜¯å¦ä¸åŒï¼Œå³æ˜¯å¦æœ‰ç‰©ç†ä½ç§»
                     currentLine.indexOf(oldTileInLine) !== newLine.indexOf(newTileInLine))) {
                    hasMovedInLine = true;
                    break;
                }
            }
            return { newLine: newLine, scoreChange: newScoreAdded, hasMovedInLine: hasMovedInLine, hasMergedInLine: hasMergedInLine };
        }


        async function move(direction) {
            if (gameOver || win || isAnimating) return; // æ¸¸æˆç»“æŸã€èƒœåˆ©æˆ–æ­£åœ¨åŠ¨ç”»æ—¶ï¼Œä¸å“åº”æ–°çš„ç§»åŠ¨
            isAnimating = true; // é”å®šæ¸¸æˆï¼Œå¼€å§‹åŠ¨ç”»

            let boardChanged = false; // æ•´ä¸ªæ£‹ç›˜æ˜¯å¦å‘ç”Ÿå˜åŒ–
            let currentScoreAdded = 0; // æœ¬æ¬¡ç§»åŠ¨å¢åŠ çš„æ€»åˆ†æ•°
            let currentMoveCausedMerge = false; // æœ¬æ¬¡ç§»åŠ¨æ˜¯å¦å¯¼è‡´äº†ä»»ä½•åˆå¹¶

            // ä¸´æ—¶å­˜å‚¨æ‰€æœ‰ç –å—ç§»åŠ¨å‰çš„ (r, c) ä½ç½®ï¼Œç”¨äºåç»­åŠ¨ç”»è®¡ç®—ã€‚
            // æ¯æ¬¡ç§»åŠ¨å‰éƒ½æ›´æ–°æ‰€æœ‰ç –å—çš„æ—§ä½ç½®ã€‚
            tiles.forEach(tile => {
                tile.oldR = tile.r;
                tile.oldC = tile.c;
            });


            // éå†æ£‹ç›˜çš„è¡Œæˆ–åˆ—ï¼Œè¿›è¡Œæ»‘åŠ¨å’Œåˆå¹¶æ“ä½œ
            if (direction === 'left' || direction === 'right') {
                for (let r = 0; r < GRID_SIZE; r++) {
                    let row = [];
                    for (let c = 0; c < GRID_SIZE; c++) {
                        row.push(board[r][c]); // è·å–ç°æœ‰ç –å—å¯¹è±¡
                    }

                    if (direction === 'right') {
                        row.reverse(); // å‘å³ç§»åŠ¨æ—¶ï¼Œåè½¬è¡Œä»¥å‘å·¦å¤„ç†
                    }

                    // å¯¹å½“å‰è¡Œæ‰§è¡Œæ“ä½œ
                    const { newLine, scoreChange, hasMovedInLine, hasMergedInLine } = operateLine(row);

                    if (hasMovedInLine) { // åªæœ‰è¡Œå†…å‘ç”Ÿå˜åŒ–æ‰è¿›è¡Œæ›´æ–°
                        if (direction === 'right') {
                            newLine.reverse(); // æ¢å¤åŸå§‹åˆ—é¡ºåº
                        }
                        boardChanged = true;
                        if (hasMergedInLine) currentMoveCausedMerge = true;
                        currentScoreAdded += scoreChange;

                        // æ›´æ–°å½“å‰æ£‹ç›˜æ ¼å­çš„ç –å—ä½ç½®/å€¼
                        for (let c = 0; c < GRID_SIZE; c++) {
                            const newTile = newLine[c]; // è¿™æ˜¯ä» operateLine è¿”å›çš„ Tile å¯¹è±¡å¼•ç”¨

                            if (newTile) {
                                // æ›´æ–°ç –å—çš„å½“å‰ä½ç½® (r, c)
                                newTile.r = r;
                                newTile.c = c;
                            }
                            board[r][c] = newTile; // å°† Tile å¯¹è±¡ï¼ˆæˆ– nullï¼‰æ”¾å…¥æ£‹ç›˜
                        }
                    }
                }
            } else if (direction === 'up' || direction === 'down') {
                for (let c = 0; c < GRID_SIZE; c++) {
                    let col = [];
                    for (let r = 0; r < GRID_SIZE; r++) {
                        col.push(board[r][c]);
                    }

                    if (direction === 'down') {
                        col.reverse(); // å‘ä¸‹ç§»åŠ¨æ—¶ï¼Œåè½¬åˆ—ä»¥å‘ä¸Šå¤„ç†
                    }

                    // å¯¹å½“å‰åˆ—æ‰§è¡Œæ“ä½œ
                    const { newLine, scoreChange, hasMovedInLine, hasMergedInLine } = operateLine(col);

                    if (hasMovedInLine) { // åªæœ‰åˆ—å†…å‘ç”Ÿå˜åŒ–æ‰è¿›è¡Œæ›´æ–°
                        if (direction === 'down') {
                            newLine.reverse(); // æ¢å¤åŸå§‹è¡Œé¡ºåº
                        }
                        boardChanged = true;
                        if (hasMergedInLine) currentMoveCausedMerge = true;
                        currentScoreAdded += scoreChange;

                        for (let r = 0; r < GRID_SIZE; r++) {
                            const newTile = newLine[r];

                            if (newTile) {
                                newTile.r = r;
                                newTile.c = c;
                            }
                            board[r][c] = newTile;
                        }
                    }
                }
            }

            if (boardChanged) {
                score += currentScoreAdded;
                scoreElement.textContent = score;

                // æ ¹æ®ç§»åŠ¨ç»“æœæ’­æ”¾éŸ³æ•ˆ
                if (currentMoveCausedMerge) {
                    playSound('merge');
                } else {
                    playSound('move');
                }

                // æ¸…ç†ä¸å†åœ¨æ£‹ç›˜ä¸Šçš„ç –å—ï¼ˆä¾‹å¦‚ï¼Œå·²åˆå¹¶æ¶ˆå¤±çš„ç –å—ï¼‰
                let newTilesMap = new Map();
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const tile = board[r][c];
                        if (tile) {
                            newTilesMap.set(tile.id, tile);
                            // åŒæ—¶ç¡®ä¿ mergedFrom ç –å—ä¹Ÿä»å…¨å±€ 'tiles' map ä¸­ç§»é™¤ï¼ˆå®ƒä»¬åœ¨ DOM æ¸²æŸ“æ—¶ä¹Ÿä¼šè¢«ç§»é™¤ï¼‰
                            if (tile.mergedFrom) {
                                tile.mergedFrom.forEach(mergedId => newTilesMap.delete(mergedId));
                            }
                        }
                    }
                }
                tiles = newTilesMap; // æ›´æ–°å…¨å±€ 'tiles' map

                renderTiles(); // é‡æ–°æ¸²æŸ“æ‰€æœ‰æ´»åŠ¨ç –å—ï¼ˆå®ƒä»¬çš„ position å°†æ›´æ–°ï¼ŒCSS transition å°†æ¥ç®¡ï¼‰

                // ç­‰å¾…ç§»åŠ¨å’Œåˆå¹¶åŠ¨ç”»å®Œæˆ
                await new Promise(resolve => setTimeout(resolve, ANIMATION_DURATION));


                // åŠ¨ç”»å®Œæˆåï¼Œæ·»åŠ æ–°çš„ç –å—å¹¶æ£€æŸ¥æ¸¸æˆçŠ¶æ€
                if (win) {
                    showOverlay("æ­å–œä½ ï¼ä½ è¾¾åˆ°äº† 2048ï¼ğŸ‰", true);
                } else {
                    addRandomTile(); // è¿™ä¼šæ’­æ”¾ 'newTile' éŸ³æ•ˆ
                    renderTiles(); // æ¸²æŸ“æ–°æ·»åŠ çš„ç –å—ï¼Œå¹¶æ’­æ”¾å…¶â€œå‡ºç°â€åŠ¨ç”»
                    await new Promise(resolve => setTimeout(resolve, ANIMATION_DURATION + 50)); // ç­‰å¾…æ–°ç –å—å‡ºç°åŠ¨ç”»

                    if (checkGameOver()) {
                        gameOver = true;
                        showOverlay("æ¸¸æˆç»“æŸï¼å†æ¥ä¸€å±€ï¼Ÿ", false);
                    }
                }
            }
            isAnimating = false; // è§£é”æ¸¸æˆï¼Œå…è®¸ä¸‹ä¸€æ¬¡ç§»åŠ¨
        }

        // é”®ç›˜è¾“å…¥äº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('keydown', (e) => {
            if (gameOver || win || isAnimating) return; // æ¸¸æˆç»“æŸã€èƒœåˆ©æˆ–æ­£åœ¨åŠ¨ç”»æ—¶ï¼Œä¸å“åº”æŒ‰é”®

            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    move('up');
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    move('down');
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    move('left');
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    move('right');
                    break;
            }
        });

        // --- è§¦æ§äº‹ä»¶ç›‘å¬å™¨ ---
        gameBoardElement.addEventListener('touchstart', (e) => {
            if (gameOver || win || isAnimating) return;
            e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„æ»šåŠ¨è¡Œä¸º
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }, { passive: false }); // ä½¿ç”¨ { passive: false } å…è®¸ preventDefault

        gameBoardElement.addEventListener('touchmove', (e) => {
            // åœ¨ touchmove æœŸé—´é˜»æ­¢é»˜è®¤æ»šåŠ¨è¡Œä¸ºï¼Œä»¥ç¡®ä¿æµç•…çš„æ¸¸æˆä½“éªŒ
            e.preventDefault();
        }, { passive: false });

        gameBoardElement.addEventListener('touchend', (e) => {
            if (gameOver || win || isAnimating) return;
            const touch = e.changedTouches[0];
            const touchEndX = touch.clientX;
            const touchEndY = touch.clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            // æ£€æŸ¥æ»‘åŠ¨è·ç¦»æ˜¯å¦è¾¾åˆ°é˜ˆå€¼
            if (Math.abs(dx) > TOUCH_SWIPE_THRESHOLD || Math.abs(dy) > TOUCH_SWIPE_THRESHOLD) {
                // åˆ¤æ–­æ˜¯æ°´å¹³æ»‘åŠ¨è¿˜æ˜¯å‚ç›´æ»‘åŠ¨
                if (Math.abs(dx) > Math.abs(dy)) {
                    // æ°´å¹³æ»‘åŠ¨
                    if (dx > 0) {
                        move('right');
                    } else {
                        move('left');
                    }
                } else {
                    // å‚ç›´æ»‘åŠ¨
                    if (dy > 0) {
                        move('down');
                    } else {
                        move('up');
                    }
                }
            }
            // é‡ç½®èµ·å§‹è§¦æ‘¸ç‚¹
            touchStartX = 0;
            touchStartY = 0;
        });

        // é˜²æ­¢æ•´ä¸ªé¡µé¢çš„é»˜è®¤æ»šåŠ¨ï¼Œå°¤å…¶åœ¨æŸäº›ç§»åŠ¨æµè§ˆå™¨ä¸Š
        document.addEventListener('touchmove', (e) => {
            if (gameBoardElement.contains(e.target)) {
                // å¦‚æœè§¦æ‘¸äº‹ä»¶åœ¨æ¸¸æˆæ¿å†…éƒ¨ï¼Œåˆ™ç”±æ¸¸æˆæ¿çš„ touchmove å¤„ç†ï¼Œé˜»æ­¢é»˜è®¤è¡Œä¸º
                // å¦åˆ™ï¼Œå…è®¸é¡µé¢å…¶ä»–éƒ¨åˆ†çš„æ»šåŠ¨
            } else {
                // å¯¹äºæ¸¸æˆæ¿ä¹‹å¤–çš„åŒºåŸŸï¼Œå…è®¸æ­£å¸¸çš„é¡µé¢æ»šåŠ¨
            }
        }, { passive: false });


        newGameButtonTop.addEventListener('click', initializeGame);

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ¸¸æˆ
        initializeGame();

    </script>
</body>
</html>
